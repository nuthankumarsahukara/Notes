Abstract Classes and Methods.

In the world of Java programming, abstract classes play an important role in defining the structure of classes and their behavior in the hierarchy. They provide a blueprint for other teams to follow, and some methods remain undefined. This flexibility empowers developers to generate a well-organized and scalable codebase.

A class that is declared with the abstract keyword is known as an abstract class in Java. It can have abstract and non-abstract methods (method with the body).

Before learning the Java abstract class, let's understand the abstraction in Java first.

Data abstraction is the process of hiding certain details and showing only essential information to the user.

Abstraction can be achieved with either abstract classes or interfaces

The abstract keyword is a non-access modifier, used for classes and methods:

Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).

Points to Remember:

An abstract class must be declared with an abstract keyword.
It can have abstract and non-abstract methods.
It cannot be instantiated.
it should contain atleast one abstract method.
It can have constructors and static methods also.
It can have final methods which will force the subclass not to change the body of the method.

An abstract class can have both abstract and regular methods:

Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).

Syntax:abstract void printStatus();//no method body and abstract  

abstract class Bike{  
  abstract void run();  
}  
class Honda4 extends Bike{  
void run(){
System.out.println("running safely");
}  
public static void main(String args[]){  
 Bike obj = new Honda4();  
 obj.run();  
}  
}  

Key Features of Abstract Classes
Abstract Methods: Abstract classes can have abstract methods, which are declared without a body. Subclasses must provide concrete implementations for these methods.

Concrete Methods: Abstract classes can also contain concrete methods with defined behavior. Subclasses inherit these methods along with their implementations.

Cannot be Instantiated: Abstract classes cannot be instantiated directly. They serve as a blueprint for other classes and must be extended to be used.

Can Have Constructors: Abstract classes can have constructors, which are invoked when a subclass object is created. These constructors are used to initialize the state of the abstract class.

When to Use Abstract Classes?
Abstract classes are beneficial in various scenarios, including:

Code Reusability: Abstract classes facilitate code reuse by allowing common methods to be implemented once and inherited by multiple subclasses.

Defining a Common Interface: Abstract classes can define a common interface for a group of related classes, ensuring consistency in their structure and behavior.

Enforcing Method Implementation: Abstract classes can enforce the implementation of certain methods by declaring them as abstract, thereby ensuring that subclasses provide necessary functionality.
  
Best Practices for Using Abstract Classes
To make the most out of abstract classes in Java, consider the following best practices:

Keep Abstract Classes Concise: Aim to keep abstract classes focused on a single responsibility to maintain clarity and simplicity.

Use Abstract Classes for Related Objects: Abstract classes are best suited for scenarios where a group of related objects share common characteristics and behaviors.

Prefer Interfaces for Multiple Inheritance: If a class needs to inherit from multiple sources, prefer using interfaces over abstract classes, as Java doesn't support multiple inheritance for classes.

Provide Meaningful Abstract Methods: When defining abstract methods, ensure they have clear and meaningful names that convey their purpose to subclasses.

Real Scenario of Abstract Class
In this example, Shape is the abstract class, and its implementation is provided by the Rectangle and Circle classes.

Mostly, we do not know about the implementation class (which is hidden to the end user), and an object of the implementation class is provided by the factory method.

A factory method is a method that returns the instance of the class. We will learn about the factory method later.

In this example, if we create the instance of Rectangle class, draw() method of Rectangle class will be invoked.

File Name: TestAbstraction1.java

abstract class Shape{  
abstract void draw();  
}  
//In real scenario, implementation is provided by others i.e. unknown by end user  
class Rectangle extends Shape{  
void draw(){System.out.println("drawing rectangle");}  
}  
class Circle1 extends Shape{  
void draw(){System.out.println("drawing circle");}  
}  
//In real scenario, method is called by programmer or user  
class TestAbstraction1{  
public static void main(String args[]){  
Shape s=new Circle1();//In a real scenario, object is provided through method, e.g., getShape() method  
s.draw();  
}  
}  
Output:

drawing circle
Another Example of Abstract Class in Java
File Name: TestBank.java

abstract class Bank{    
abstract int getRateOfInterest();    
}    
class SBI extends Bank{    
int getRateOfInterest(){return 7;}    
}    
class PNB extends Bank{    
int getRateOfInterest(){return 8;}    
}    
    
class TestBank{    
public static void main(String args[]){    
Bank b;  
b=new SBI();  
System.out.println("Rate of Interest is: "+b.getRateOfInterest()+" %");    
b=new PNB();  
System.out.println("Rate of Interest is: "+b.getRateOfInterest()+" %");    
}}    
Output:

Rate of Interest is: 7 %
Rate of Interest is: 8 %

Abstract Class Having Constructor, Data Member and Methods
An abstract class can have a data member, abstract method, method body (non-abstract method), constructor, and even main() method.

File Name: TestAbstraction2.java

//Example of an abstract class that has abstract and non-abstract methods  
 abstract class Bike{  
   Bike(){System.out.println("bike is created");}  
   abstract void run();  
   void changeGear(){System.out.println("gear changed");}  
 }  
//Creating a Child class which inherits Abstract class  
 class Honda extends Bike{  
 void run(){System.out.println("running safely..");}  
 }  
//Creating a Test class which calls abstract and non-abstract methods  
 class TestAbstraction2{  
 public static void main(String args[]){  
  Bike obj = new Honda();  
  obj.run();  
  obj.changeGear();  
 }  
}  
Output:

bike is created
running safely..
gear changed
Rule: If there is an abstract method in a class, that class must be abstract.

class Bike12{  
abstract void run();  
}  
Output:

compile time error
Rule: If we are extending an abstract class that has an abstract method, we must either provide the implementation of the method or make this class abstract.

