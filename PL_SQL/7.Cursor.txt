PL/SQL Cursor
A cursor is a temporary work area created in the system memory when a SQL statement is executed. A cursor contains information on a select statement and the rows of data accessed by it.
This temporary work area is used to store the data retrieved from the database, and manipulate this data. A cursor can hold more than one row, but can process only one row at a time. The set of rows the cursor holds is called the active set.
There are two types of cursors in PL/SQL:
1.Implicit Cursors
2.Explicit Cursors

1) PL/SQL Implicit Cursors
The implicit cursors are automatically generated by Oracle while an SQL statement is executed, if you don't use an explicit cursor for the statement. These are created by default to process the statements when DML statements like INSERT, UPDATE, DELETE etc. are executed. Orcale provides some attributes known as Implicit cursor's attributes to check the status of DML operations. Some of them are: %FOUND, %NOTFOUND, %ROWCOUNT and %ISOPEN.

The following table specifies the status of the cursor with each of its attribute.
1.%FOUND
Its return value is TRUE if DML statements like INSERT, DELETE and UPDATE affect at least one row or more rows or a SELECT INTO statement returned one or more rows. Otherwise it returns FALSE.

2.%NOTFOUND Its return value is TRUE if DML statements like INSERT, DELETE and UPDATE affect no row, or a SELECT INTO statement return no rows. Otherwise it returns FALSE. It is a just opposite of %FOUND.

3.%ISOPEN It always returns FALSE for implicit cursors, because the SQL cursor is automatically closed after executing its associated SQL statements.

4.%ROWCOUNT It returns the number of rows affected by DML statements like INSERT, DELETE, and UPDATE or returned by a SELECT INTO statement.

Example:
decalre
 rcount number(2);
begin
update employee set sal=sal+1000 where deptno=20;

if sql%notfound then
dbms_output.put_line('No Record Found to Update');
else
rcount:=sql%rowcount;
dbms_output.put_line('Record Found to Update are '||rcount);
end if;
end;

2) PL/SQL Explicit Cursors
The Explicit cursors are defined by the programmers to gain more control over the context area. These cursors should be defined in the declaration section of the PL/SQL block. It is created on a SELECT statement which returns more than one row.

DECLARE
OPEN
FETCH
       |	NO
EMPTY
       |	yes
CLOSE

Steps while working with an explicit cursor.
1.Declare the cursor to initialize in the memory.
2.Open the cursor to allocate memory.
3.Fetch the cursor to retrieve data.
4. Close the cursor to release allocated memory.

1) Declare the cursor: It defines the cursor with a name and the associated SELECT statement.
Syntax: CURSOR name IS SELECT statement;

2) Open the cursor: It is used to allocate memory for the cursor and make it easy to fetch the rows returned by the SQL statements into it.
Syntax: OPEN cursor_name;

3) Fetch the cursor: It is used to access one row at a time. You can fetch rows from the above-opened cursor as follows:
Syntax: FETCH cursor_name INTO variable_list;

4) Close the cursor:It is used to release the allocated memory. The following syntax is used to close the above-opened cursors.
Syntax: Close cursor_name;

Example:

declare 
e_no employee.empno%type;
e_name employee.ename%type;
e_sal employee.sal%type;

cursor c_emp is select empno,ename,sal from employee;

begin
open c_emp;
loop
fetch c_emp into e_no,e_name,e_sal;
exit when c_emp%notfound;
dbms_output.put_line('Empno = '||e_no||' EmpName = '||e_name||' Salary = '||e_sal);
end loop;
close c_emp;
end;
/

Example 2:
declare 
e_no employee.empno%type;
e_name employee.ename%type;
e_sal employee.sal%type;

cursor c_emp is select empno,ename,sal from employee;

begin
open c_emp;
loop
fetch c_emp into e_no,e_name,e_sal;
exit when c_emp%notfound;
dbms_output.put_line('Empno = '||e_no||' EmpName = '||e_name||' Salary = '||e_sal);
if e_sal>=5000 then
update employee set comm =comm+500 where empno=e_no;
elsif e_sal>=3000 then
update employee set comm =comm+300 where empno=e_no;
else
update employee set comm =comm+100 where empno=e_no;
end if;
end loop;
close c_emp;
end;
/

Example 3:
declare 
e_no employee.empno%type;
e_name employee.ename%type;
e_sal employee.sal%type;
e_comm employee.comm%type;

cursor c_emp is select empno,ename,sal,comm from employee;

begin
open c_emp;
loop
fetch c_emp into e_no,e_name,e_sal,e_comm;
exit when c_emp%notfound;
dbms_output.put_line('Empno = '||e_no||' EmpName = '||e_name||' Salary = '||e_sal);
if e_sal>=5000 then
	update employee set comm =comm+500 where empno=e_no;
elsif e_sal>=3000 then
	update employee set comm =comm+300 where empno=e_no;
else
	update employee set comm =comm+100 where empno=e_no;
end if;
if e_comm is null then
	update employee set comm =100 where empno=e_no;
end if;
end loop;
close c_emp;
end;
/

Cursor FOR Loop:
When using FOR LOOP you need not declare a record or variables to store the cursor values, need not open, fetch and close the cursor. These functions are accomplished by the FOR LOOP automatically.
General Syntax for using FOR LOOP:
FOR record_name IN cusror_name
LOOP
process the row...
END LOOP;

Example:

declare
 	cursor emp_cur is select ename,job,sal from employee;
	emp_rec emp_cur%rowtype;
begin
	for emp_rec in emp_cur
	loop
	dbms_output.put_line(emp_rec.ename || ' ' ||emp_rec.job || ' ' ||emp_rec.sal);
	end loop;
end; 

Delete The employee :
declare
 	cursor emp_cur is select empno,ename,job,sal from employee;
	emp_rec emp_cur%rowtype;
begin
	for emp_rec in emp_cur
	loop
	dbms_output.put_line(emp_rec.ename || ' ' ||emp_rec.job || ' ' ||emp_rec.sal);
	delete from employee where empno=emp_rec.empno;
	end loop;
end; 