PL/SQL - Collections
A collection is an ordered group of elements having the same data type. Each element is identified by a unique subscript that represents its position in the collection.

Why Collections?
Just about all modern programming languages provide support for collections. A collection can be loosely defined as a group of ordered elements, all of the same type, that allows programmatic access to its elements through an index. Commonly used collection types used in the programming world include arrays, maps, and lists.

	Storing elements in a collection can provide a number of advantages. For starters, collections can help to simplify code. If you need to process a number of items of a similar type, storing these items in a collection will allow you to loop through each element with ease, referencing each one by an index. In addition, most languages define collection types that contain built-in methods to operate on the collection. For example, a method might allow you to remove all elements from a collection in a single command.
	
	Probably the biggest advantage a collection can provide is improved application performance. Developers utilize collections to 'cache' static data that needs to be regularly accessed. This results in reduced calls to a database.

Collection Methods PL/SQL provides the built-in collection methods that make collections easier to use.

EXISTS(n)
Returns TRUE if the nth element in a collection exists; otherwise returns FALSE.

COUNT
Returns the number of elements that a collection currently contains.

LIMIT
Checks the maximum size of a collection.

FIRST
Returns the first (smallest) index numbers in a collection that uses the integer subscripts.

LAST
Returns the last (largest) index numbers in a collection that uses the integer subscripts.
 
PRIOR(n)
Returns the index number that precedes index n in a collection.

NEXT(n)
Returns the index number that succeeds index n.

EXTEND
Appends one null element to a collection.

EXTEND(n)
Appends n null elements to a collection.

EXTEND(n,i) 
Appends n copies of the ith element to a collection.

TRIM
Removes one element from the end of a collection.

TRIM(n)
Removes n elements from the end of a collection.

DELETE
Removes all elements from a collection, setting COUNT to 0.

DELETE(n)
Removes the nth element from an associative array with a numeric key or a nested table. If the 14 associative array has a string key, the element corresponding to the key value is deleted. If n is null, DELETE (n) does nothing.

DELETE(m,n) 
Removes all elements in the range m..n from an associative array or nested table. If m is larger 15 than n or if m or n is null, DELETE(m,n) does nothing.

Traditional Approaches:-
With the release of Oracle 7, Oracle introduced the PL/SQL Table. By using PL/SQL Tables, it was possible to create a collection of items, all of the same type, indexed by an integer.
TYPE book_title_tab IS TABLE OF book.title%TYPE
INDEX BY BINARY_INTEGER;
The only way to access the elements of a PL/SQL Table was through its numeric index. Still, it was the first construct that gave PL/SQL developers array-like access to data.

	In version 8, Oracle introduced two collection types, Nested Tables and Varrays. At this time, the PL/SQL Table was renamed to 'index-by table'. As of Oracle 9i, PL/SQL Tables (index-by tables) have again been renamed to Associative Arrays. The Associative Array functions much the same way the PL/SQL Table of old did. However, the Associative Array does contain some enhanced functionality

Oracle Collections Today
PL/SQL provides three collection types -
1.Index-by tables or Associative array
2.Nested table
3.Variable-size array or Varray

Varray Example:-

declare

type namesarray is varray(5) of varchar2(10);
type grades is varray(5) of integer;

names namesarray;
marks grades;

total integer;
begin
names:=namesarray('sai','kumar','vinod','arjun','ganesh');
marks:=grades(98,97,85,68,98);

total:=names.count;
dbms_output.put_line('Total '||total||' students');
for i in 1 .. total loop
	dbms_output.put_line('Student :'||names(i)||' Marks:'||marks(i));
end loop;
end;
/

Example 2:
declare
cursor e_employs is
select ename from employee;
type e_list is varray(20) of employee.ename%type;

name_list e_list :=e_list();

counter integer:=0;

begin
	for n in e_employs loop
	counter :=counter+1;
	name_list.extend;
	name_list(counter):=n.ename;
	
	dbms_output.put_line('Employ( '||counter ||'):'||name_list(counter));
	end loop;
end;

Index-By Table (OR) associative array
An index-by table (also called an associative array) is a set of key-value pairs. Each key is unique and is used to locate the corresponding value. The key can be either an integer or a string.

	An index-by table is created using the following syntax. Here, we are creating an index-by table named table_name, the keys of which will be of the subscript_type and associated values will be of the element_type

Syntax
TYPE type_name IS TABLE OF element_type [NOT NULL] INDEX BY subscript_type;
table_name type_name;

Example1 :
declare
type salary is table of number index by varchar2(20);
salary_list salary;
name varchar2(20);
begin
salary_list('Nuthan'):=62000;
salary_list('Pro'):=75000;
salary_list('ganesh'):=85000;

name:=salary_list.first;

	while name is not null loop
	dbms_output.put_line('Salary of '||name ||' is '||to_Char(salary_list(name)));
	name:=salary_list.next(name);
	end loop;
end;
/

Nested table:

declare
type names_table is table of varchar2(10);
type grades is table of integer;

names names_table;
marks grades;
total integer;

begin
names:=names_table('Nuthan','ganesh','sai','kumar','vinod');
marks:=grades(98,97,78,87,92);

total:=names.count;

dbms_output.put_line('Total Number '||total||'Students');

for i in 1 .. total loop
	dbms_output.put_line('Student :'||names(i)||',Marks:' ||marks(i));
end loop;
end;
/ 