INDEXES in ORACLE
Use indexes to speed up queries. Indexes speeds up searching of information in tables. So create indexes on those columns which are frequently used in WHERE conditions. Indexes are helpful if the operations return only small portion of data i.e. less than 15% of data is retrieved from tables.

Follow these guidelines for creating indexes:-
1.Do not create indexes on small tables i.e. where number of rows are less. (Full table scan itself will be faster if table is small)
2.Do not create indexes on those columns which contain many null values.
3.Do not create BTree index on those columns which contain many repeated values. In this case create BITMAP indexes on these columns.
4.Limit the number of indexes on tables because, although they speed up queries, but at the same time DML operations becomes very slow as all the indexes have to updated whenever an Update, Delete or Insert takes place on tables.

view index statement:- view index with already exists table with primary key and foreign key and still we didn't create any index too on table;

syntax: 	select index_name,index_type,visibility,status from all_indexes where table_name='<TN>';
Example: 	select index_name,index_type,visibility,status from all_indexes where table_name='dept';

CREATE INDEX statement:-
To create a new index for a table, you use the CREATE INDEX statement as follows:
syntax:CREATE INDEX index_name ON table_name(column] [column2,...]);

Example:	create table members(
	member_id int generated by default as identity,
	first_name varchar(20) not null,
	last_name varchar(20) not null,
	gender char(1) not null,
	dob date not null,
	email varchar2(25) not null,
	primary key(member_id));

create index for single column:		
create index idx1 on members(first_name);

create index for single column:		
create index idx2 on members(first_name,last_name);

Removing an index :-
To remove an index, you use the DROP INDEX statement:
syntax:DROP INDEX index_name;

Example: drop index idx1;

UNIQUE index :-
	An index can be unique or non-unique. A unique index ensures that no two rows of a table have duplicate values in the indexed column (or columns). A non-unique index does not impose this restriction on the indexed column's values.
Syntax:CREATE UNIQUE INDEX index name ON table_name (column1 [, column2,...]);

Example:cretae unique index email_index on members(email);

FUNCTION BASED Indexes
Function Based indexes are built on expressions rather than on column values. A function-based index calculates the result of a function that involves one or more columns and stores that result in the index.
Syntax: CREATE INDEX index_name ON table_name (expression)

expression can be an arithmetic expression or an expression that contains a function such as a SQL function, PL/SQL function, and package function.

Example: create index upper_mem on members(upper(last_name));

BITMAP INDEXES
Create Bitmap indexes on those columns which contains many repeated values and when tables are large. City column in EMP table is a good canditate for Bitmap index because it contain many repeated values. To create a composite index give the following command. Oracle bitmap index for indexing columns with low cardinality.
syntax:CREATE BITMAP INDEX index_name ON table_name(column] [column2,...]);

Example:	create bitmap index gender_mem on members(gender);
	create bitmap index emp_job on employee(job);

CLUSTERS:-
	If you two are more tables are joined together on a single column and most of the time you issue joinqueries on them, then consider creating a cluster of these tables.

	A cluster is a group tables that share the same data blocks i.e. all the tables are physically stored together.For example EMP and DEPT table are joined on DEPTNO column. If you cluster them, Oracle physically stores all rows for each department from both the emp and dept tables in the same data blocks.

1.Since cluster stores related rows of different tables in same data blocks, Disk I/O is reduced and access time improves for joins of clustered tables.
2.Each cluster key value is stored only once each in the cluster and the cluster index, no matter how many rows of different tables contain the value.

Therefore, less storage might be required to store related table and index data in a cluster than is necessary in non-clustered table format.

Example:	create cluster cl1 (deptno number(3));
	create index idc on cluster cl1;
create table dpt(deptno number(3),dname varchar2(20)) cluster cl1(deptno);
create table emp(eno number(2),ename varchar2(20),deptno number(3))cluster cl1(deptno);
drop cluster cl1;


Here’s a simple example with explanation of how indexes work in Oracle.

Scenario: Employees Table
Let’s say you have the following table:

CREATE TABLE employees (
    emp_id      NUMBER PRIMARY KEY,
    emp_name    VARCHAR2(100),
    department  VARCHAR2(50),
    salary      NUMBER
);

You insert 1,000,000 records into this table. Now, imagine you frequently run the following query:

SELECT * FROM employees WHERE emp_name = 'John';

Without Index:
Oracle will perform a full table scan – it checks every row to find 'John'.

This is slow when the table has millions of rows.

Create Index:
CREATE INDEX emp_name_idx ON employees(emp_name);
Now, Oracle creates a B-Tree index on emp_name.

What Happens Internally:
Oracle creates a tree-like structure where each value (like 'John') is mapped to ROWIDs.
Instead of scanning the whole table, it jumps to the correct location using this tree.
So now, the same query becomes much faster:

SELECT * FROM employees WHERE emp_name = 'John';
Oracle uses the emp_name_idx to locate matching rows quickly.

Query Performance Before vs After
Operation			Without Index	With Index
Table scan time		High		Low
CPU & I/O usage		High		Reduced
Query performance		Slow		Fast


Example for Composite Index
CREATE INDEX emp_dept_idx ON employees(emp_name, department);
Used in:

SELECT * FROM employees WHERE emp_name = 'John' AND department = 'HR';
When Index is NOT Used

Oracle may not use the index if:
You use LIKE '%ohn' (leading wildcard).

The table is small (optimizer may prefer full scan).

Index is on a low-cardinality column and optimizer estimates it's not efficient.
